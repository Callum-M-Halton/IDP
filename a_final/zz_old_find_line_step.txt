void follow_line_step() {
  int suggested_timer = correct_trajectory();
  bool approaching_EOL = true;
    //(state.approaching == approachables.tunnel || state.approaching == approachables.box);
  if (suggested_timer != suggested_timers_by_line_end_likelihoods.none) {
    // if there's an existing timer
    if (suggested_timer == suggested_timers_by_line_end_likelihoods.as_before) {
      // if the timer is valid (not set to the null state of 0)...
      // ... and it has run out, assume buggy off line
      Serial.println(state.timer_end - millis());
      if (state.timer_end != 0 && millis() >= state.timer_end) {
        if (approaching_EOL) {
          if (true/*state.approaching == approachables.tunnel*/) {
            //next_sector();
            traverse_tunnel();
          // === Otherwise assume approaching box ===
          // If the sector_code was straight_before_start_junct then we're going home
          } else if (state.sector_code == 12) {
            go_home();
          // Otherwise we're depositing a block
          } else {
            deposit_block();
          }
        } else {
          refind_line();
        }
      }
    // Otherwise if expecting an end of line...
    } else if (approaching_EOL 
        // ... or gone from [0, 1, 0] to [0, 0, 0]
        || suggested_timer == suggested_timers_by_line_end_likelihoods.high) {
      Serial.println("Starting left line timer");
      // set timer
      state.timer_end = millis() + suggested_timer;
    // Otherwise not expecting end of line and not [0, 1, 0] to [0, 0, 0]...
    } else {
      // ... so set a timer_end to the null state 0, which will never run out
      state.timer_end = 0;
    }
  }
}