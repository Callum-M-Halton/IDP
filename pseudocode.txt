

// CONSTANTS
const speeds = {
	tiny: _____
	low: ____
	med: _____
	high: _____
}
const modes = enum {
	start,
	approaching_symmetric_junct,
	making_right_turn,
	basic, // (basic line following)
	approaching_block_on_line,
	testing_block,
	lowering_grabber,
	approaching_tunnel,
	in_tunnel,
	approaching_right_turn_to_take,
	approaching_box,
	raising_grabber,
	doing_a_180,
	lost_line,
}

const line_end_likelihood = enum {
	low,
	med,
	high
}

const SAMPLE_LENGTH = _________
const CURVING_LEFT_THRESHOLD = ________

// directions
offset_dirs = enum {none, left, right, unknown}
// extents
offset_exts = enum {none, little, mid, far}

// Hardware Commands
void set_right(speed)
void set_left(speed)
[int, int, int] get_sensors()
int get_juct_sensor()

// Not Hardware
void set_motor_speed(is_right, speed):
	if is_right:
		if motor_speeds[1] != speed:
			set_right(speed)
			motor_speeds[1] == speed
	else:
		// ...





// initial robot state dict
state = {
	motor_speeds: [0, 0],
	dir: [straight, null],
	grabber_down: False,
	sector: 0,
	// dead-reckoned and waymarked
	pos: start_pos,
	// ONLY EVER CURVING LEFT
	curving_left: False,
	avg_turns_disparity: 0,
	// List of recent motor_speeds arrays of length SAMPLE_LENGTH
	motor_speeds_sample: [[],[]],
	state.mode = modes.start
	state.prev_mode = modes.start
}

//  For < line width spaced sensors
enum correct_trajectory():
	sensor_vals = get_sensors()
	switch sensor_vals:
		case [0, 1, 0]:
			state.line_offset = [offset_dirs.none, offset_exts.none]
			set_motor_speed(True, speeds.med)
		case [0, 1, 1]:
			state.line_offset = [offset_dirs.left, offset_exts.little]
			set_motor_speed(True, speeds.med)
		case [1, 1, 0]:
			state.line_offset = [offset_dirs.right, offset_exts.little]
			set_motor_speed(False, speeds.med)
		case [0, 0, 1]:
			state.line_offset = [offset_dirs.left, offset_exts.mid]
			set_motor_speed(True, speeds.low)
		case [1, 0, 0]:
			state.line_offset = [offset_dirs.right, offset_exts.mid]
			set_motor_speed(False, speeds.low)
		case [0, 0, 0]:
			// Figure out how to drive motors
			state.line_offset[1] = offset_exts.far
			if state.line_offset[0] = offset_dirs.left:
				set_motor_speed(True, speeds.tiny)
			elif state.line_offset[0] = offset_dirs.right:
				set_motor_speed(False, speeds.tiny)
			else:
				state.line_offset[0] = unknown:
				state.prev_mode = state.mode
				state.mode = modes.lost_line

			// Figure out likelihood that end of line reached
			switch state.line_offset:
				case [offset_dirs.left, offset_exts.mid]
			if state.line_offset = [offset_dirs.left, offset_exts.mid]:

				return line_end_likelihood.low
			else:
				state.line_offset = [offset_dirs.right, offset_exts.far]
				
				return line_end_likelihood.low
	return False


void update_curving_left():
	motor_speeds_sample[i].append(motor_speeds)
	if motor_speeds_sample.length() == SAMPLE_LENGTH:
		tot = 0
		for past_motor_speeds in motor_speeds_sample:
			tot += past_motor_speeds[1] - past_motor_speeds[0]
		state.avg_turns_disparity = tot / SAMPLE_LENGTH

	if motor_speeds_sample.length() > SAMPLE_LENGTH:
		rem = motor_speeds_sample[0]
		state.avg_turns_disparity -= ((rem[1] - rem[0]) / SAMPLE_LENGTH)
		motor_speeds_sample.remove_index(0)

		state.avg_turns_disparity += ((motor_speeds[1] - motor_speeds[0]) / SAMPLE_LENGTH)
		motor_speeds_sample.append(motor_speeds)

	// UNSAFE CODE
	if state.avg_turns_disparity > CURVING_LEFT_THRESHOLD:
		if state.curving_left == False:
			state.curving_left = True
			state.sector++
	else:
		if state.curving_left == True:
			state.curving_left = False
			state.sector++


void loop():
	// Line Following
	// REPLACE WITH FOLLOW LINE VAL IN STATE AND HAVE MODE SETTER FUNCTION WHICH CONFIGURES IT
	if state.mode not in [
			modes.making_right_turn, modes.testing_block, modes.lowering_grabber, modes.in_tunnel, modes.raising_grabber, modes.doing_a_180]:
		lost_line = correct_trajectory()
		// FIGURE OUT IF WE'RE CURVING LEFT
		update_curving_left()


	if state.mode == modes.approaching_symmetric_junct:
		if 
	if state.mode == making_right_turn:












